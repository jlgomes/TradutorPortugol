/**
 * JTB template file created by SF JavaCC plugin 1.5.17+ wizard for JTB 1.4.0.2+ and JavaCC 1.5.0+
 */
/*tipo TURMA = vetor [1..20] de reais; // definição do tipo do vetor
	TURMA: VTURMA; // declaracao da variável vetor
*/
options
{
  JDK_VERSION = "1.5";
  static = false;
  JTB_P = "Telas";
  lookahead=2;
  FORCE_LA_CHECK=true;
}

PARSER_BEGIN(EG3)
package Telas;

// this import is not needed as it is generated by JTB
// import Telassyntaxtree.*;
// this import is needed as it is not generated by JTB
import Telas.TabelaSintatico.hash;
import Telas.AnaliseSemantica.registro;
import Telas.TabelaSintatico.Variavel;
import Telas.visitor.*;
import java.io.FileInputStream;
import java.io.IOException;
import javax.swing.JOptionPane;
import java.util.ArrayList;

public class EG3
{
  String erro="";
  int simerro = 0;
  Token t=null;
  Token tr=null;
  Token tf=null;
  Token tipo=null;
  Token funcao = null;
  Token reg = null;
  Token reg2=null;
  int escopo=0;
  int fim;
  int vetor=0;
  int pos,num=1;//pos = hash.funcaohashing(num); num =  hash.inserir(pos, num, yytext());
  int atrib=0;
  int retorno=0;
  String tipoFuncao=null;
  TabelaSintatico tbs = new TabelaSintatico();
  ArrayList<Variavel> var = new ArrayList<Variavel>();
  ArrayList<Variavel> varLoc = new ArrayList<Variavel>();
  ArrayList<Variavel> par = new ArrayList<Variavel>();
  ArrayList<registro> argumentos = new ArrayList<registro>();
  ArrayList<registro> atribuicao = new ArrayList<registro>();
  ArrayList<registro> relacional = new ArrayList<registro>();
  String atribuicaoComposta=null;
  public static void main(String args [])
  {
    System.out.println("Reading from standard input...");
    System.out.print("Enter an expression like \"1+(2+3)*var;\" :");
    EG3 eg = new EG3(System.in);
    try {
      Start start = eg.Start();
      DepthFirstVoidVisitor v = new MyVisitor();
      start.accept(v);
      //JOptionPane.showMessageDialog (null, "Sem erro Sintático.\n", null, JOptionPane.PLAIN_MESSAGE);
    }
    catch (Exception e)
    {
      //System.out.println("Oops.");
      //System.out.println(e.getMessage());
      eg.erro = e.getMessage();
      eg.simerro = 1;
    }catch (TokenMgrError E) {
      eg.erro = E.getMessage();
      eg.simerro = 1;
    }
  }
  public EG3(String codigo) throws IOException  {
	 FileInputStream fs = new java.io.FileInputStream(codigo);
     EG3 eg1 = new EG3(fs);
    try {
      TraducaoPortugolEmC.programaAll.clear();
      tbs.excluirtabelahash();
      Start start = eg1.Start();
      DepthFirstVoidVisitor v = new MyVisitor();
      start.accept(v);
      //tbs.mostrarhash();
      //System.out.println(TraducaoPortugolEmC.programaAll);
      TraducaoPortugolEmC.execute();
      //JOptionPane.showMessageDialog (null, "Sem erro Sintático.\n", null, JOptionPane.PLAIN_MESSAGE);
    }catch (Exception e) {
      //System.out.println("Oops.");
      //System.out.println(e.getMessage());
      erro = e.getMessage();
      simerro = 1;
    }catch (TokenMgrError E) {
        erro = E.getMessage();
        simerro = 1;
    }finally    {
      fs.close();    }
  }
  
  public boolean registroExiste() {
        hash aux=null;
        for (int i = 0; i < 10; i++) {
           aux = tbs.tabela[i];
           while (aux != null) {
	  		  if(aux.registro != null && aux.registro.token.toString().equals(tipo.toString()))
	    		return true;
	  		  aux = aux.prox;
	       }
	    }
	    return false;
  }
}

class MyVisitor extends DepthFirstVoidVisitor
{
  public void visit(NodeToken n)
  {
    //System.out.println("visit " + n.tokenImage);
  }
}


PARSER_END(EG3)

SKIP :
{
  " " { TraducaoPortugolEmC.programaAll.add(" "); }
| "!"
| "@" 
| "$"
| "%"
| "ç"
| "&"
| "ª"
| "º"
| "§"
| "´"
| "`"
| "^"
| "~"
| "#"
| "\t" { TraducaoPortugolEmC.programaAll.add("\t"); }
| "\n" { TraducaoPortugolEmC.programaAll.add("\n"); }
| "\r" { TraducaoPortugolEmC.programaAll.add("\r"); }
| < "{" 
    (
      "\n"
    | "\r"
    | "\r\n"
    | " "
    | ["a"-"z","A"-"Z"]
    | ["0"-"9"]
    | ["^","~","´","`","-","_",",","*","\\","'","\"","/","%","?","\7","\b","\n","\r","\t","+","(",")","$","#","@","&","=","!",";",":",">","<","|","º","ª","§","ç","¹","²","³","£","¢","¬","á","é","í","ó","ú","à","è","ì","ò","ù","Á","É","Í","Ó","Ú","À","È","Ì","Ò","Ù","Â","Ê","Î","Ô","Û","â","ê","î","ô","û","ã","Ã","õ","Õ","]","[","¨","."]
    )*
    ("}")? >
}

TOKEN : /* LITERALS */
{
  < TIPO :
    < inteiro > ([ "l", "L" ])? 
  | < real > ([ "l", "L" ])? 
  | < caractere > ([ "l", "L" ])?
  | < logico > ([ "l", "L" ])?
    > {TraducaoPortugolEmC.programaAll.add(image.toString().trim());}
| < #inteiro :  "inteiro"> 
| < #real : "real" > 
| < #caractere : "caractere" > 
| < #logico : "logico" > 
}

TOKEN: //palavras reservadas
{
  < INICIO_LITERAL : "inicio" > { TraducaoPortugolEmC.programaAll.add("inicio"); }
| < E : "e" > { TraducaoPortugolEmC.programaAll.add("e"); }
| < OU : "ou" > { TraducaoPortugolEmC.programaAll.add("ou"); }
| < NAO : "nao" > { TraducaoPortugolEmC.programaAll.add("nao"); }
| < FIM_LITERAL : "fim" > { TraducaoPortugolEmC.programaAll.add("fim"); }
| < STRING : "\"" ([ "a"-"z", "A"-"Z", "0"-"9","^","~","´","`"," ","-","_",",","*","\\","'","/","%","?","\7","\b","\r","\t","+","(",")","$","#","@","&","=","!",";",":",">","<","|","º","ª","§","ç","¹","²","³","£","¢","¬","á","é","í","ó","ú","à","è","ì","ò","ù","Á","É","Í","Ó","Ú","À","È","Ì","Ò","Ù","Â","Ê","Î","Ô","Û","â","ê","î","ô","û","ã","Ã","õ","Õ","]","[","¨","." ])* ("\"")? >{ TraducaoPortugolEmC.programaAll.add(image.toString().trim());}
| < Tipo : "tipo"> { TraducaoPortugolEmC.programaAll.add("tipo"); }
| < Registro : "registro" > { TraducaoPortugolEmC.programaAll.add("registro"); }
| < FimRegistro : "fimregistro" > { TraducaoPortugolEmC.programaAll.add("fimregistro"); }
| < Escolha : "escolha" > { TraducaoPortugolEmC.programaAll.add("escolha"); }
| < Caso : "caso" > { TraducaoPortugolEmC.programaAll.add("caso"); }
| < FimEscolha : "fimescolha" > { TraducaoPortugolEmC.programaAll.add("fimescolha"); }
| < Contrario : "contrario" > { TraducaoPortugolEmC.programaAll.add("contrario"); }
| < DIGITO  : (["0"-"9"])+ > {TraducaoPortugolEmC.programaAll.add(image.toString().trim());}
| < PONTO_FLUTUANTE : (["0"-"9"])+["."](["0"-"9"])+> {TraducaoPortugolEmC.programaAll.add(image.toString().trim());}
| < SE: "se" > { TraducaoPortugolEmC.programaAll.add("se"); }
| < DE: "de" > { TraducaoPortugolEmC.programaAll.add("de"); }
| < MODULO: "modulo" > { TraducaoPortugolEmC.programaAll.add("modulo"); }
| < MOD: "mod" > { TraducaoPortugolEmC.programaAll.add("mod"); }
| < ATE: "ate" > { TraducaoPortugolEmC.programaAll.add("ate"); }
| < DIV: "div" > { TraducaoPortugolEmC.programaAll.add("div"); }
| < FACA: "faca" > { TraducaoPortugolEmC.programaAll.add("faca"); }
| < PARA: "para" > { TraducaoPortugolEmC.programaAll.add("para"); }
| < LEIA: "leia" > { TraducaoPortugolEmC.programaAll.add("leia"); }
| < FIMSE: "fimse" > { TraducaoPortugolEmC.programaAll.add("fimse"); }
| < ENTAO: "entao" > { TraducaoPortugolEmC.programaAll.add("entao"); }
| < SENAO: "senao" > { TraducaoPortugolEmC.programaAll.add("senao"); }
| < PASSO: "passo" > { TraducaoPortugolEmC.programaAll.add("passo"); }
| < FALSO: "falso" > { TraducaoPortugolEmC.programaAll.add("falso"); }
| < REPITA: "repita" > { TraducaoPortugolEmC.programaAll.add("repita"); }
| < FIMPARA: "fimpara" > { TraducaoPortugolEmC.programaAll.add("fimpara"); }
| < ESCREVA: "escreva" > { TraducaoPortugolEmC.programaAll.add("escreva"); }
| < RETORNE: "retorne" > { TraducaoPortugolEmC.programaAll.add("retorne"); }
| < ENQUANTO: "enquanto" > { TraducaoPortugolEmC.programaAll.add("enquanto"); }
| < FIMMODULO: "fimmodulo" > { TraducaoPortugolEmC.programaAll.add("fimmodulo"); }
| < VERDADEIRO: "verdadeiro" > { TraducaoPortugolEmC.programaAll.add("verdadeiro"); }
| < FIMENQUANTO: "fimenquanto" > { TraducaoPortugolEmC.programaAll.add("fimenquanto"); }
| < FIMALGORITMO: "fimalgoritmo"> { TraducaoPortugolEmC.programaAll.add("fimalgoritmo"); }| < VETOR: "vetor" > { TraducaoPortugolEmC.programaAll.add("vetor"); }
| < MATRIZ: "matriz" > { TraducaoPortugolEmC.programaAll.add("matriz"); }
}
//int IDENTIFIER = 63;
TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER :
    < LETTER >
    (
      < LETTER >
    | < DIGIT >
    )* > { TraducaoPortugolEmC.programaAll.add(image.toString().trim());}    
| < #LETTER : [ "a"-"z", "A"-"Z" ] >
| < #DIGIT : [ "0"-"9" ] >
}

TOKEN : /* IDENTIFIERS */
{
    < VAR : "var:" > { TraducaoPortugolEmC.programaAll.add("var:"); }
|   < APARENTESE: "(" > { TraducaoPortugolEmC.programaAll.add("("); }
|   < FPARENTESE: ")" > { TraducaoPortugolEmC.programaAll.add(")"); }
|   < PONTOEVIRGULA: ";" > { TraducaoPortugolEmC.programaAll.add(";"); }
|   < IGUAL: "=" > { TraducaoPortugolEmC.programaAll.add("="); }
|   < DOISPONTOS: ":" > { TraducaoPortugolEmC.programaAll.add(":"); }
|   < VIRGULA: "," > { TraducaoPortugolEmC.programaAll.add(","); }
|   < ACOLCHETE: "[" > { TraducaoPortugolEmC.programaAll.add("["); }
|   < FCOLCHETE: "]" > { TraducaoPortugolEmC.programaAll.add("]"); }
|   < RECEBE: "<-" > { TraducaoPortugolEmC.programaAll.add("<-"); }
|   < PONTOS: ".." > { TraducaoPortugolEmC.programaAll.add(".."); }
|   < PONTO: "." > { TraducaoPortugolEmC.programaAll.add("."); }
|   < MAIOR: ">" > { TraducaoPortugolEmC.programaAll.add(">"); }
|   < MENOR: "<" > { TraducaoPortugolEmC.programaAll.add("<"); }
|   < MAIORIGUAL: ">=" > { TraducaoPortugolEmC.programaAll.add(">="); }
|   < MENORIGUAL: "<=" > { TraducaoPortugolEmC.programaAll.add("<="); }
|   < DIFERENTE: "<>" > { TraducaoPortugolEmC.programaAll.add("<>"); }
|   < MAIS : "+" > { TraducaoPortugolEmC.programaAll.add("+"); }
|   < MENOS: "-" > { TraducaoPortugolEmC.programaAll.add("-"); }
|   < MULTIPLICAR: "*" > { TraducaoPortugolEmC.programaAll.add("*"); }
|   < DIVIDIR: "/" > { TraducaoPortugolEmC.programaAll.add("/"); }
}

SPECIAL_TOKEN :
{
  < Especiais :  "¢" | "£" | "¬" | "¹" | "²" | "³">
}

void Start() :
{}
{
  Programa()
}

void Programa() :
{}
{
  (< VAR > (GDecl() | FunDeclaracao())+ )?  < INICIO_LITERAL > Declaracao() < FIMALGORITMO > < EOF >
}

void Declaracao():
{}
{
  GlobalDeclaracao() (CorpoDeclLista())*}

void GlobalDeclaracao():
{}
{
  (GDecl())* (CorpoDeclLista())*
}
/*tipo TURMA = vetor [1..20] de reais; // definição do tipo do vetor
	TURMA: VTURMA; // declaracao da variável vetor
*/
void GDecl():
{}
{
  
  < Tipo > tr = < IDENTIFIER > < IGUAL > DefTipo()
| VarDeclaracao()
//| vazio
}

void DefTipo():
{}
{
  <  Registro > (VarDeclaracao())+ < FimRegistro > < PONTOEVIRGULA >
  {
    pos = tbs.funcaohashing(num);
	num = tbs.inserir(pos, num, tr, var);
    //System.out.println("Registro: "+tr);
    tr=null;
    var.clear();
  }
| t = < VETOR > < ACOLCHETE > < DIGITO > < PONTOS > < DIGITO > < FCOLCHETE > < DE > (tipo = < TIPO > | tipo = < IDENTIFIER >) < PONTOEVIRGULA >
  {
    pos = tbs.funcaohashing(num);
    var.add(new Variavel(t, tipo, escopo, vetor));
	num = tbs.inserir(pos, num, tr, var);
    //System.out.println("Registro: "+tr);
    tr=null;
    var.clear();
  }| t = < MATRIZ > < ACOLCHETE > < DIGITO > < PONTOS > < DIGITO > (< VIRGULA > < DIGITO > < PONTOS > < DIGITO >)+ < FCOLCHETE > < DE > (tipo = < TIPO > | tipo = < IDENTIFIER >) < PONTOEVIRGULA >
  {
    pos = tbs.funcaohashing(num);
    var.add(new Variavel(t, tipo, escopo, vetor));
	num = tbs.inserir(pos, num, tr, var);
    //System.out.println("Registro: "+tr);
    tr=null;
    var.clear();
  }
}

void TipoEspecificador():
{}
{
  tipo = < TIPO >
| tipo = < IDENTIFIER >
}

void VarDeclaracao():
{}
{
  TipoEspecificador() < DOISPONTOS > VarDeclaracaoI()
}

void VarDeclaracaoI():
{}
{
  VarListaNum() < PONTOEVIRGULA >
}

void VarListaNum():
{}
{
  VarItemNum() (VNum())*
}

void VNum():
{}
{    < VIRGULA > VarItemNum() 
//| vazio
}

void VarItemNum():
{}
{
  t = < IDENTIFIER > VarItemVetor()
    {
	if(tr==null && tf==null)
	{
	  if(!registroExiste()  && !(tipo.toString().equals("inteiro") || tipo.toString().equals("real") || tipo.toString().equals("caractere") || tipo.toString().equals("logico")) ){		  AnaliseSemantica.EscreverArquivo("Erro o tipo \""+tipo.toString() + "\" não existe, Linha: "+tipo.beginLine+" Coluna: "+tipo.beginColumn);
	      //System.out.println("Erro o tipo \""+tipo.toString() + "\" não existe, Linha: "+tipo.beginLine+" Coluna: "+tipo.beginColumn);
	  }else
	  {
	      Telas.TabelaSintatico.Registro reg = TraducaoPortugolEmC.registroExiste(tipo.image);
    	  if(reg!=null && (reg.variaveis.get(0).token.image.equals("vetor") || reg.variaveis.get(0).token.image.equals("matriz")))
			 vetor=1;
		  //System.out.println("Vvetor: "+vetor);
			
	      pos = tbs.funcaohashing(num);
	      num = tbs.inserir(pos, num, t, tipo, escopo, vetor);
	      //System.out.println(tipo+" : "+t+" Escopo: "+escopo+" Vetor: "+vetor);
	      vetor=0;
	   }
	}else
	{
	  int existe=0;
	  if(tr!=null){
	    if(!registroExiste()  && !(tipo.toString().equals("inteiro") || tipo.toString().equals("real") || tipo.toString().equals("caractere") || tipo.toString().equals("logico")) ){
		  AnaliseSemantica.EscreverArquivo("Erro o tipo \""+tipo.toString() + "\" não existe, Linha: "+tipo.beginLine+" Coluna: "+tipo.beginColumn);
	  	  //System.out.println("Erro o tipo \""+tipo.toString() + "\" não existe, Linha: "+tipo.beginLine+" Coluna: "+tipo.beginColumn);
	    }else	    {	      for(int i =0 ; i < var.size(); i++)
  	    	if(var.get(i).token.image.equals(t.image)){
  	    	    AnaliseSemantica.EscreverArquivo("Erro a variável \""+t.toString() + "\" já  tinha sido declarada, Linha: "+t.beginLine+" Coluna: "+t.beginColumn);
  	    		//System.out.println("Erro a variável \""+t.toString() + "\" já  tinha sido declarada, Linha: "+t.beginLine+" Coluna: "+t.beginColumn);
  	    		existe=1;
  	    	}
    	  if(existe==0){//nao existir a variavel declarada
    	    Telas.TabelaSintatico.Registro reg = TraducaoPortugolEmC.registroExiste(tipo.image);    	    if(reg!=null && (reg.variaveis.get(0).token.image.equals("vetor") || reg.variaveis.get(0).token.image.equals("matriz")))
				vetor=1;
			//System.out.println("Rvetor: "+vetor);	
            var.add(new Variavel(t, tipo, escopo, vetor));
          }
        }
	  }else{
	    if(!registroExiste()  && !(tipo.toString().equals("inteiro") || tipo.toString().equals("real") || tipo.toString().equals("caractere") || tipo.toString().equals("logico")) ){
		  AnaliseSemantica.EscreverArquivo("Erro o tipo \""+tipo.toString() + "\" não existe, Linha: "+tipo.beginLine+" Coluna: "+tipo.beginColumn);
	  	  //System.out.println("Erro o tipo \""+tipo.toString() + "\" não existe, Linha: "+tipo.beginLine+" Coluna: "+tipo.beginColumn);
	    }else{
	      for(int i =0 ; i < par.size(); i++)
  	     	if(par.get(i).token.image.equals(t.image)){
  	     	    AnaliseSemantica.EscreverArquivo("Erro a variável \""+t.toString() + "\" já  tinha sido declarada como parâmetro, Linha: "+t.beginLine+" Coluna: "+t.beginColumn);
  	    		//System.out.println("Erro a variável \""+t.toString() + "\" já  tinha sido declarada como parâmetro, Linha: "+t.beginLine+" Coluna: "+t.beginColumn);
  	    		existe=1;
  	     	}
	      for(int i =0 ; i < varLoc.size(); i++)
  	    	if(varLoc.get(i).token.image.equals(t.image)){
  	    	    AnaliseSemantica.EscreverArquivo("Erro a variável \""+t.toString() + "\" já  tinha sido declarada, Linha: "+t.beginLine+" Coluna: "+t.beginColumn);
  	    		//System.out.println("Erro a variável \""+t.toString() + "\" já  tinha sido declarada, Linha: "+t.beginLine+" Coluna: "+t.beginColumn);
  	    		existe=1;
  	    	}
    	  if(existe==0){//nao existir a variavel declarada
    	    Telas.TabelaSintatico.Registro reg = TraducaoPortugolEmC.registroExiste(tipo.image);
    	    if(reg!=null && (reg.variaveis.get(0).token.image.equals("vetor") || reg.variaveis.get(0).token.image.equals("matriz")))
				vetor=1;
			//System.out.println("Fvetor: "+vetor);
		    varLoc.add(new Variavel(t, tipo, escopo, vetor));
		  }
		}
	  }
	  //System.out.println(tipo+" : "+t+" Escopo: "+escopo+" Vetor: "+vetor);
	  vetor=0;
	}
  }
}

void VarItemVetor():
{}
{
  (    //< ACOLCHETE > < DIGITO > < PONTOS > ( < DIGITO > | t1 = < IDENTIFIER >) < FCOLCHETE > { vetor = 1;  AnaliseSemantica.LerVariavelExiste(t1, null, varLoc, par); }
   < RECEBE > VarComplemento()
//| vazio
  )?
}

void VarComplemento():
{Token valor=null;}
{
   (< MENOS >)? valor=< DIGITO > { AnaliseSemantica.atribuicaoSimples(tipo,valor); }
|  (< MENOS >)? valor=< IDENTIFIER > { AnaliseSemantica.atribuicaoSimples(tipo,valor); }
|  (< MENOS >)? valor=< PONTO_FLUTUANTE > { AnaliseSemantica.atribuicaoSimples(tipo,valor); }
|  valor=< STRING > { AnaliseSemantica.atribuicaoSimples(tipo,valor); }
|  valor=< FALSO > { AnaliseSemantica.atribuicaoSimples(tipo,valor); }
|  valor=< VERDADEIRO > { AnaliseSemantica.atribuicaoSimples(tipo,valor); }
}

void FunDeclaracao():
{escopo=1;}
{
  < MODULO > tf = < IDENTIFIER > < APARENTESE > (Params())? < FPARENTESE > CompostoDecl() < FIMMODULO > < PONTOEVIRGULA >
{
  pos = tbs.funcaohashing(num);
  num = tbs.inserir(pos, num, tf, par, varLoc,tipoFuncao);
  //System.out.println("Função: "+tf);
  tf=null;
  escopo=0;
  par.clear();
  varLoc.clear();
  tipoFuncao=null;
}
//| vazio
}

void Params():
{}
{
  ParamLista()
//| vazio
}

void ParamLista():
{}
{
  Param() (PParam())*
}

void PParam():
{}
{
  < VIRGULA > Param() 
//| vazio
}

void Param():
{}
{
  TipoEspecificador() < DOISPONTOS > t = < IDENTIFIER > (ParamI())?
  {
    if(!registroExiste()  && !(tipo.toString().equals("inteiro") || tipo.toString().equals("real") || tipo.toString().equals("caractere") || tipo.toString().equals("logico")) ){
		  AnaliseSemantica.EscreverArquivo("Erro o tipo \""+tipo.toString() + "\" não existe, Linha: "+tipo.beginLine+" Coluna: "+tipo.beginColumn);
	  	  //System.out.println("Erro o tipo \""+tipo.toString() + "\" não existe, Linha: "+tipo.beginLine+" Coluna: "+tipo.beginColumn);
    }else	{	  int existe=0;
      for(int i =0 ; i < par.size(); i++)
  	     if(par.get(i).token.image.equals(t.image)){
  	       		AnaliseSemantica.EscreverArquivo("Erro a variável \""+t.toString() + "\" já  tinha sido declarada, Linha: "+t.beginLine+" Coluna: "+t.beginColumn);
  	    		//System.out.println("Erro a variável \""+t.toString() + "\" já  tinha sido declarada, Linha: "+t.beginLine+" Coluna: "+t.beginColumn);
  	    		existe=1;
  	     }
       if(existe==0)       {
         Telas.TabelaSintatico.Registro reg = TraducaoPortugolEmC.registroExiste(tipo.image);
    	 if(reg!=null && (reg.variaveis.get(0).token.image.equals("vetor") || reg.variaveis.get(0).token.image.equals("matriz")))
			vetor=1;
			//System.out.println("Fvetor: "+vetor);         par.add(new Variavel(t, tipo, escopo, vetor));
         //System.out.println(tipo+" : "+t+" Escopo: "+escopo+" Vetor: "+vetor);
       }
    }
    vetor=0;
  }
}

void ParamI():
{Token t1=null;}
{
  < ACOLCHETE > (< DIGITO > | t1 = < IDENTIFIER >)? (ParamIVetor())* < FCOLCHETE > { vetor = 1; AnaliseSemantica.LerVariavelExiste(t1, null, varLoc, par);}
//| vazio
}

void ParamIVetor():
{Token t1=null; }{
  < VIRGULA > (< DIGITO > | t1 = < IDENTIFIER >) { AnaliseSemantica.LerVariavelExiste(t1, null, varLoc, par); }}

void CompostoDecl():
{}
{
  (LocalDeclaracoes())* CorpoDeclLista()
}

void LocalDeclaracoes():
{}
{    VarDeclaracao()
//| vazio
//| < Tipo > < IDENTIFIER > "=" <  Registro > (VarDeclaracao())+ < FimRegistro > ";"
}

void CorpoDeclLista():
{}
{
  Corpo() (CLista())*
}

void CLista():
{}
{
  Corpo()
//| vazio
}

void Corpo():
{}
{
  ExpressaoDecl()
| SelecaoDecl()
| EscolhaDecl()
| IteracaoDecl()
| RetornoDecl()
| EntradaSaidaDecl()
| GDecl()
}

void ExpressaoDecl():
{}
{
  Expressao() < PONTOEVIRGULA >
| < PONTOEVIRGULA >
}

void SelecaoDecl():
{}
{
  < SE > < APARENTESE > CondicaoDecl() < FPARENTESE > < ENTAO > SelecaoDeclI()
}

void SelecaoDeclI():
{}
{
  < INICIO_LITERAL > (Corpo())+ < FIM_LITERAL > < PONTOEVIRGULA > SelecaoDeclII()
| (Corpo())+ SelecaoDeclII()
}

void SelecaoDeclII():
{}
{
  < FIMSE > < PONTOEVIRGULA >
| < SENAO > SelecaoDeclIII()
}

void SelecaoDeclIII():
{}
{
  < INICIO_LITERAL > (Corpo())+ < FIM_LITERAL > < PONTOEVIRGULA > < FIMSE > < PONTOEVIRGULA >
| (Corpo())+ < FIMSE > < PONTOEVIRGULA >
}

void IteracaoDecl():
{Token t1=null;}
{
  < ENQUANTO > < APARENTESE > CondicaoDecl() < FPARENTESE > < FACA > (Corpo())+ < FIMENQUANTO > < PONTOEVIRGULA >
| < REPITA > (Corpo())+ < ATE > < APARENTESE > CondicaoDecl() < FPARENTESE > < PONTOEVIRGULA >
| < PARA > t1 = < IDENTIFIER > < DE > < DIGITO > < ATE > < DIGITO > IteracaoDeclI() { AnaliseSemantica.LerVariavelExiste(t1, null, varLoc, par); }
}

void IteracaoDeclI():
{}
{
  < FACA > (Corpo())+ < FIMPARA > < PONTOEVIRGULA >
| < PASSO > (< MENOS >)? < DIGITO > < FACA > (Corpo())+ < FIMPARA > < PONTOEVIRGULA >
}

void RetornoDecl():
{retorno=1;}
{
  < RETORNE > RetornoDeclI(){retorno=0;}
}

void RetornoDeclI():
{}
{
  < PONTOEVIRGULA >
| Expressao() < PONTOEVIRGULA > 
| < FALSO >{ tipoFuncao="logico"; }
| < VERDADEIRO > { tipoFuncao="logico"; }
| < STRING > { tipoFuncao="caractere"; }
}

void EntradaSaidaDecl():
{}
{
  < LEIA > < APARENTESE > Lendo() < FPARENTESE > < PONTOEVIRGULA >
| < ESCREVA > < APARENTESE > Escrevendo() < FPARENTESE > < PONTOEVIRGULA >
}

void Lendo():
{}
{
  VarLerNum() {}
}

void VarLerNum():
{}
{
  VarItemLerNum() (VLerNum())*
}

void VLerNum():
{}
{
    < VIRGULA > VarLerNum() 
//| vazio
}

void VarItemLerNum():
{Token t1=null; atribuicaoComposta="2"; atribuicao.clear();}
{
  t1 = < IDENTIFIER > VarLerVetor() { atribuicao.add(new registro(t1, reg,null)); AnaliseSemantica.atribuicaoComposta(atribuicao, varLoc, par); reg=null; atribuicao.clear(); atribuicaoComposta=null;}
}

void VarLerVetor():
{Token t2=null;
Token t1=null;}
{
  (
    < ACOLCHETE > ( < DIGITO > | t2 = < IDENTIFIER >) (ParamIVetor())* < FCOLCHETE > (< PONTO > reg = < IDENTIFIER > (< ACOLCHETE > ( < DIGITO > | t1 = < IDENTIFIER >) (ParamIVetor())* < FCOLCHETE >)? )? { AnaliseSemantica.LerVariavelExiste(t2, null, varLoc, par); AnaliseSemantica.LerVariavelExiste(t1, null, varLoc, par);}
	| < PONTO > reg = < IDENTIFIER > (< ACOLCHETE > ( < DIGITO > | t2 = < IDENTIFIER >) (ParamIVetor())* < FCOLCHETE >)? { AnaliseSemantica.LerVariavelExiste(t2, null, varLoc, par);}
  )?
}

/*void VarLerVetor():
{}
{
  (
    (< ACOLCHETE > (< DIGITO > | t1 = < IDENTIFIER >)? (ParamIVetor())* < FCOLCHETE >IndiceVetor())+ (< PONTO > reg = < IDENTIFIER > (IndiceVetor())* )? 
	| < PONTO > reg = < IDENTIFIER > (IndiceVetor())*
  )?
}*/

void Escrevendo():
{}
{
  EscreveItem() (EscrevendoRec())*
}

void EscrevendoRec():
{}
{
  < VIRGULA > EscreveItem()
//| vazio
}

void EscreveItem():
{Token t1=null; atribuicaoComposta="2"; atribuicao.clear();}
{
  t1 = < IDENTIFIER > VarLerVetor() { atribuicao.add(new registro(t1, reg,null)); AnaliseSemantica.atribuicaoComposta(atribuicao, varLoc, par); reg=null;atribuicao.clear(); atribuicaoComposta=null;}
| < STRING >
| < FALSO >
| < VERDADEIRO >
| < DIGITO >
| < PONTO_FLUTUANTE >
//| < IDENTIFIER > erro de identificador
}

void EscolhaDecl():
{Token t1=null;}
{
  < Escolha > t1 = < IDENTIFIER > EscolhaCaso() (EscolhaExcessao())? < FimEscolha > < PONTOEVIRGULA > { AnaliseSemantica.LerVariavelExiste(t1, null, varLoc, par);}
}

void EscolhaCaso():
{}
{
  EscCaso() (EscolhaRec())*
//| vazio
}

void EscolhaRec():
{}
{
  EscCaso() 
//| vazio
}

void EscCaso():
{}
{
  < Caso > < DIGITO > < DOISPONTOS > (Corpo())+
}

void EscolhaExcessao():
{}
{
  < Caso > < Contrario > < DOISPONTOS > (Corpo())+
//| vazio
}

void Expressao():
{}
{
  SimplesEpressao()
  {		tipoFuncao = AnaliseSemantica.atribuicaoComposta(atribuicao, varLoc, par);
		if(retorno==0)
			tipoFuncao=null;
		atribuicaoComposta=null;
    	atrib=0;
    	atribuicao.clear();
  }
}

void CondicaoDecl():
{}
{
  ExpressaoRelacional() Relacional() ExpressaoRelacional() (Logico() ExpressaoRelacional() Relacional() ExpressaoRelacional())*  {
    AnaliseSemantica.comparacaoRelacional(relacional, varLoc, par);
    relacional.clear();  }
}

void Valor():
{Token token=null;  atribuicaoComposta="2"; }
{
   (< MENOS >)? token=< DIGITO > { relacional.add(new registro(token, reg,null)); atribuicaoComposta=null;}
|  (< MENOS >)? token=< IDENTIFIER > [Var()] { relacional.add(new registro(token, reg,null)); reg = null; atribuicaoComposta=null; }
|  (< MENOS >)? token=< PONTO_FLUTUANTE > { relacional.add(new registro(token, reg,null)); atribuicaoComposta=null; }
|  token=< STRING > { relacional.add(new registro(token, reg,null)); atribuicaoComposta=null; }|  token=< VERDADEIRO > { relacional.add(new registro(token, reg,null)); atribuicaoComposta=null; }
|  token=< FALSO > { relacional.add(new registro(token, reg,null)); atribuicaoComposta=null; }
}

void ExpressaoRelacional():
{}{
  Valor()
| < APARENTESE > Valor() < FPARENTESE >}

void SimplesEpressao():
{}
{
  SomaExpressao()
}

void Relacional():
{}
{
  < MENORIGUAL >
| < MENOR >
| < MAIOR >
| < MAIORIGUAL >
| < IGUAL >
| < DIFERENTE >
}

void Logico():{}
{
  < E >
| < OU >
| < NAO >}

void SomaExpressao():
{}
{
  Termo() (SomaExpressaoI())*//erro  line 1501, column 3.
}

void SomaExpressaoI():
{}
{
  Soma() Termo()
//| vazio
}

void Soma():
{Token token=null;}
{
  token=< MAIS >//{ atribuicao.add(new registro(token, null,null)); }
| token=< MENOS >//{ atribuicao.add(new registro(token, null,null)); }
}

void Termo():
{}
{
  Fator() (TermoI())*//erro line 1552, column 3.
}

void TermoI():
{}
{
  Mult() Fator() 
//| vazio
}

void Mult():
{Token token=null;}
{
  token=< MULTIPLICAR >//{ atribuicao.add(new registro(token, null,null)); }
| token=< DIVIDIR >//{ atribuicao.add(new registro(token, null,null)); }
}

void Fator():
{ Token var=null;
Token t1=null;}
{
  < APARENTESE > SimplesEpressao() < FPARENTESE >
| funcao = < IDENTIFIER > VarAtivacao(funcao) { if(atrib!=1){  atribuicao.add(new registro(funcao, reg,null)); reg=null; } }
| var = < DIGITO > { atribuicao.add(new registro(var, null,null)); }
| var = < PONTO_FLUTUANTE > { atribuicao.add(new registro(var, null,null)); }
| < DIV > < APARENTESE > (< DIGITO > | var = < IDENTIFIER >) < VIRGULA > (< DIGITO > | t1 = < IDENTIFIER >)< FPARENTESE >{ AnaliseSemantica.LerVariavelExiste(var, null, varLoc, par); AnaliseSemantica.LerVariavelExiste(t1, null, varLoc, par);}
| < MOD > < APARENTESE > (< DIGITO > | var = < IDENTIFIER >) < VIRGULA > (< DIGITO > | t1 = < IDENTIFIER >)< FPARENTESE >{ AnaliseSemantica.LerVariavelExiste(var, null, varLoc, par); AnaliseSemantica.LerVariavelExiste(t1, null, varLoc, par);}
}									

void VarAtivacao(Token var):
{
  Token valor = null;
  Token var2=null;
  if(atribuicaoComposta==null)  {    atribuicaoComposta = "1";
  }
}
{
  Ativacao()  {
    AnaliseSemantica.ativacao(funcao,argumentos);
    argumentos.clear();  }
| (Var())? (var2=< RECEBE >
				(SimplesEpressao()				{
				  atribuicao.add(0,new registro(var, reg2,null)); reg2=null;
				  atribuicao.add(1,new registro(var2, null,null));
				  atrib=1;				}
				|  (< MENOS >)? valor = < IDENTIFIER > (Var())?
				{
				  atribuicao.add(0,new registro(var, reg2,null)); reg2=null;
				  atribuicao.add(1,new registro(var2, null,null));
				  atrib=1;
				}
				|  (< MENOS >)? valor = < DIGITO > { atribuicao.add(new registro(valor, null,null)); }
				|  (< MENOS >)? valor = < PONTO_FLUTUANTE > { atribuicao.add(new registro(valor, null,null)); }
				| valor = < FALSO > 
				{
				  if(reg2 != null){				    AnaliseSemantica.atribuicaoSimplesRegistro(var,reg2,valor, varLoc, par);
				    reg2 = null;
				  }else				  {				    AnaliseSemantica.atribuicaoSimplesVariavel(var,valor, varLoc, par);
				  }
				}
				| valor = < VERDADEIRO > 
				{
				  if(reg2 != null){
				    AnaliseSemantica.atribuicaoSimplesRegistro(var,reg2,valor, varLoc, par);
				    reg2 = null;
				  }else
				  {
				    AnaliseSemantica.atribuicaoSimplesVariavel(var,valor, varLoc, par);
				  }
				}
				| valor = < STRING >
				{
				  if(reg != null){
				    AnaliseSemantica.atribuicaoSimplesRegistro(funcao,reg,valor, varLoc, par);
				    reg = null;
				  }else
				  {
				    AnaliseSemantica.atribuicaoSimplesVariavel(funcao,valor, varLoc, par);
				  }
				}
				)
			)?
}

void Var():
{Token t1=null,t2=null;}
{
  < ACOLCHETE > ( < DIGITO > | t1 = < IDENTIFIER >) (ParamIVetor())* < FCOLCHETE > (< PONTO > reg = < IDENTIFIER > (< ACOLCHETE > ( < DIGITO > | t2 = < IDENTIFIER >) (ParamIVetor())* < FCOLCHETE >)? )? {  if(atribuicaoComposta.equals("1"))  {     reg2=reg;  atribuicaoComposta="2";} AnaliseSemantica.LerVariavelExiste(t1, null, varLoc, par); AnaliseSemantica.LerVariavelExiste(t2, null, varLoc, par);}
| < PONTO > reg = < IDENTIFIER > (< ACOLCHETE > ( < DIGITO > | t1 = < IDENTIFIER >) (ParamIVetor())* < FCOLCHETE >)? {  if(atribuicaoComposta.equals("1"))  {     reg2=reg;  atribuicaoComposta="2";    } AnaliseSemantica.LerVariavelExiste(t1, null, varLoc, par);}
}

/*void Var():
{}
{
  (IndiceVetor())+ (< PONTO > reg = < IDENTIFIER > (IndiceVetor())* )? {  if(atribuicaoComposta.equals("1"))  {     reg2=reg;  atribuicaoComposta="2";} }
| < PONTO > reg = < IDENTIFIER > (IndiceVetor())* {  if(atribuicaoComposta.equals("1"))  {     reg2=reg;  atribuicaoComposta="2";    } }
}*/

void Ativacao():
{}
{
   < APARENTESE > (Args())? < FPARENTESE >
}

void Args():
{}
{
  ArgLista()
//|vazio
}

void ArgLista():
{Token arg=null; Token regi=null;}
{
  //Expressao() (ArgListaRec())*
  (
   arg=< FALSO >
|  arg=< VERDADEIRO >
|  (< MENOS >)? arg=< DIGITO >
|  (< MENOS >)? arg=< IDENTIFIER > (Var())? { regi=reg; }
|  (< MENOS >)? arg=< PONTO_FLUTUANTE >
|  arg=< STRING >  ) (ArgListaRec())*  {
    argumentos.add(0,new registro(arg, regi,null));
    reg = null;
    regi=null;  }
}

void ArgListaRec():
{Token arg=null;}
{
  //"," Expressao()
  
  < VIRGULA >    (
           arg=< FALSO >
		|  arg=< VERDADEIRO >
        |  (< MENOS >)? arg=< DIGITO >
		|  (< MENOS >)? arg=< IDENTIFIER > (Var())?
		|  (< MENOS >)? arg=< PONTO_FLUTUANTE >
		|  arg=< STRING >
 		 ) 		 {
 		   argumentos.add(new registro(arg, reg,null));
 		   reg = null; 		 }
//| vazio
}